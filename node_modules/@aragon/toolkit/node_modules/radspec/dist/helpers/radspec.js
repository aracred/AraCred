"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_web3EthAbi=_interopRequireDefault(require("web3-eth-abi")),_web3Utils=require("web3-utils"),_methodRegistry=_interopRequireDefault(require("./lib/methodRegistry")),_lib=require("../lib/"),_knownFunctions=_interopRequireDefault(require("../data/knownFunctions"));function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(source,!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}const makeUnknownFunctionNode=methodId=>({type:"string",value:"Unknown function (".concat(methodId,")")}),getSig=fn=>(0,_web3Utils.keccak256)(fn).substr(0,10),processFunctions=functions=>Object.keys(functions).reduce((acc,key)=>_objectSpread({[getSig(key)]:{source:functions[key],sig:key}},acc),{});var _default=(eth,evaluator)=>/**
   * Interpret calldata using radspec recursively. If the function signature is not in the package's known
   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry
   *
   * @param {address} addr The target address of the call
   * @param {bytes} data The calldata of the call
   * @return {Promise<radspec/evaluator/TypedValue>}
   */async(addr,data)=>{const functions=processFunctions(_knownFunctions.default);if(10>data.length)return makeUnknownFunctionNode(data);// Get method ID
const methodId=data.substr(0,10),fn=functions[methodId];// If function is not a known function, execute fallback checking Parity's on-chain signature registry
if(!fn){// Even if we pass the ETH object, if it is not on mainnet it will use Aragon's ETH mainnet node
// As the registry is the only available on mainnet
const registry=new _methodRegistry.default({networkId:"1",eth}),result=await registry.lookup(methodId);if(result){const{name}=registry.parse(result);return{type:"string",value:name// TODO: should we decode and print the arguments as well?
}}return makeUnknownFunctionNode(methodId)}// If the function was found in local radspec registry. Decode and evaluate.
const{source,sig}=fn,inputString=sig.replace(")","").split("(")[1];// get the array of input types from the function signature
let parameters=[];// If the function has parameters
if(""!==inputString){const inputs=inputString.split(","),parameterValues=_web3EthAbi.default.decodeParameters(inputs,"0x"+data.substr(10));// Decode parameters
parameters=inputs.reduce((acc,input,i)=>_objectSpread({["$".concat(i+1)]:{type:input,value:parameterValues[i]}},acc),{})}return{type:"string",value:await(0,_lib.evaluateRaw)(source,parameters,{eth,availableHelpers:evaluator.helpers.getHelpers(),to:addr})}};exports.default=_default;
//# sourceMappingURL=radspec.js.map