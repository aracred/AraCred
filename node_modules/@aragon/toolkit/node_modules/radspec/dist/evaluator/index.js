"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.evaluate=evaluate,exports.Evaluator=void 0;var _web3EthAbi=_interopRequireDefault(require("web3-eth-abi")),_web3Eth=_interopRequireDefault(require("web3-eth")),_web3Utils=_interopRequireDefault(require("web3-utils")),_bn=_interopRequireDefault(require("bn.js")),_types=_interopRequireDefault(require("../types")),_HelperManager=_interopRequireDefault(require("../helpers/HelperManager")),_defaults=require("../defaults");/**
 * @module radspec/evaluator
 */class TypedValue{constructor(type,value){if(this.type=type,this.value=value,_types.default.isInteger(this.type)&&!_bn.default.isBN(this.value)&&(this.value=new _bn.default(this.value)),"address"===this.type){if(!_web3Utils.default.isAddress(this.value))throw new Error("Invalid address \"".concat(this.value,"\""));this.value=_web3Utils.default.toChecksumAddress(this.value)}}/**
   * Get the string representation of the wrapped value
   *
   * @return {string}
   */toString(){return this.value.toString()}}/**
 * Walks an AST and evaluates each node.
 *
 * @class Evaluator
 * @param {radspec/parser/AST} ast The AST to evaluate
 * @param {radspec/Bindings} bindings An object of bindings and their values
 * @param {?Object} options An options object
 * @param {?Object} options.availablehelpers Available helpers
 * @param {?Web3} options.eth Web3 instance (used over options.ethNode)
 * @param {?string} options.ethNode The URL to an Ethereum node
 * @param {?string} options.to The destination address for this expression's transaction
 * @property {radspec/parser/AST} ast
 * @property {radspec/Bindings} bindings
 */class Evaluator{constructor(ast,bindings,{availableHelpers={},eth,ethNode,from,to,value="0",data}={}){this.ast=ast,this.bindings=bindings,this.eth=eth||new _web3Eth.default(ethNode||_defaults.DEFAULT_ETH_NODE),this.from=from&&new TypedValue("address",from),this.to=to&&new TypedValue("address",to),this.value=new TypedValue("uint",new _bn.default(value)),this.data=data&&new TypedValue("bytes",data),this.helpers=new _HelperManager.default(availableHelpers)}/**
   * Evaluate an array of AST nodes.
   *
   * @param  {Array<radspec/parser/Node>} nodes
   * @return {Promise<Array<string>>}
   */async evaluateNodes(nodes){return Promise.all(nodes.map(this.evaluateNode.bind(this)))}/**
   * Evaluate a single node.
   *
   * @param  {radspec/parser/Node} node
   * @return {Promise<string>}
   */async evaluateNode(node){var _Mathceil=Math.ceil;if("ExpressionStatement"===node.type)return(await this.evaluateNodes(node.body)).join(" ");if("GroupedExpression"===node.type)return this.evaluateNode(node.body);if("MonologueStatement"===node.type)return new TypedValue("string",node.value);if("StringLiteral"===node.type)return new TypedValue("string",node.value||"");if("NumberLiteral"===node.type)return new TypedValue("int256",node.value);if("BytesLiteral"===node.type){const length=_Mathceil((node.value.length-2)/2);return 32<length&&this.panic("Byte literal represents more than 32 bytes"),new TypedValue("bytes".concat(length),node.value)}if("BoolLiteral"===node.type)return new TypedValue("bool","true"===node.value);if("BinaryExpression"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);// String concatenation
if(("string"===left.type||"string"===right.type)&&"PLUS"===node.operator)return new TypedValue("string",left.value.toString()+right.value.toString());// TODO Additionally check that the type is signed if subtracting
switch(_types.default.isInteger(left.type)&&_types.default.isInteger(right.type)||this.panic("Cannot evaluate binary expression \"".concat(node.operator,"\" for non-integer types \"").concat(left.type,"\" and \"").concat(right.type,"\"")),node.operator){case"PLUS":return new TypedValue("int256",left.value.add(right.value));case"MINUS":return new TypedValue("int256",left.value.sub(right.value));case"STAR":return new TypedValue("int256",left.value.mul(right.value));case"POWER":return new TypedValue("int256",left.value.pow(right.value));case"SLASH":return new TypedValue("int256",left.value.div(right.value));case"MODULO":return new TypedValue("int256",left.value.mod(right.value));default:this.panic("Undefined binary operator \"".concat(node.operator,"\""));}}if("ComparisonExpression"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);let leftValue=left.value,rightValue=right.value;const bothTypesAddress=(left,right)=>// isAddress is true if type is address or bytes with size less than 20
_types.default.isAddress(left.type)&&_types.default.isAddress(right.type),bothTypesBytes=(left,right)=>_types.default.types.bytes.isType(left.type)&&_types.default.types.bytes.isType(right.type);switch(bothTypesAddress(left,right)||bothTypesBytes(left,right)?(leftValue=_web3Utils.default.toBN(leftValue),rightValue=_web3Utils.default.toBN(rightValue)):(!_types.default.isInteger(left.type)||!_types.default.isInteger(right.type))&&this.panic("Cannot evaluate binary expression \"".concat(node.operator,"\" for non-integer or fixed-size bytes types \"").concat(left.type,"\" and \"").concat(right.type,"\"")),node.operator){case"GREATER":return new TypedValue("bool",leftValue.gt(rightValue));case"GREATER_EQUAL":return new TypedValue("bool",leftValue.gte(rightValue));case"LESS":return new TypedValue("bool",leftValue.lt(rightValue));case"LESS_EQUAL":return new TypedValue("bool",leftValue.lte(rightValue));case"EQUAL_EQUAL":return new TypedValue("bool",leftValue.eq(rightValue));case"BANG_EQUAL":return new TypedValue("bool",!leftValue.eq(rightValue));}}if("TernaryExpression"===node.type)return(await this.evaluateNode(node.predicate)).value?this.evaluateNode(node.left):this.evaluateNode(node.right);if("DefaultExpression"===node.type){const left=await this.evaluateNode(node.left);let leftFalsey;return leftFalsey=_types.default.isInteger(left.type)?left.value.isZero():"address"===left.type||left.type.startsWith("bytes")?/^0x[0]*$/.test(left.value):!left.value,leftFalsey?this.evaluateNode(node.right):left}if("CallExpression"===node.type){let target;// Inject self
target="Identifier"===node.target.type&&"self"===node.target.value?this.to:await this.evaluateNode(node.target),"bytes20"!==target.type&&"address"!==target.type?this.panic("Target of call expression was not an address"):!_web3Utils.default.checkAddressChecksum(target.value)&&this.panic("Checksum failed for address \"".concat(target.value,"\""));const inputs=await this.evaluateNodes(node.inputs),outputs=node.outputs,selectedReturnValueIndex=outputs.findIndex(output=>output.selected);-1===selectedReturnValueIndex&&this.panic("No selected return value for function call \"".concat(node.callee,"\""));const returnType=outputs[selectedReturnValueIndex].type,call=_web3EthAbi.default.encodeFunctionCall({name:node.callee,type:"function",inputs:inputs.map(({type})=>({type,// web3.js 1.x requires the inputs to have names, otherwise it assumes the type is a tuple
// We can remove this if web3.js 1.x fixes this, or we upgrade to a newer major version
// For reference: this is the problematic bit in web3.js:
// https://github.com/ethereum/web3.js/blob/7d1b0eab31ff6b52c170dedc172decebea0a0217/packages/web3-eth-abi/src/index.js#L110
name:"nonEmptyName"}))},inputs.map(input=>input.value.toString()));return this.eth.call({to:target.value,data:call}).then(data=>_web3EthAbi.default.decodeParameters(outputs.map(item=>item.type),data)).then(returnData=>new TypedValue(returnType,returnData[selectedReturnValueIndex]))}if("HelperFunction"===node.type){const helperName=node.name;this.helpers.exists(helperName)||this.panic("".concat(helperName," helper function is not defined"));const inputs=await this.evaluateNodes(node.inputs),result=await this.helpers.execute(helperName,inputs,{eth:this.eth,evaluator:this});return new TypedValue(result.type,result.value)}if("PropertyAccessExpression"===node.type&&"msg"===node.target.value){if("value"===node.property)return this.value;if("sender"===node.property)return this.from;if("data"===node.property)return this.data;this.panic("Expecting value, sender or data property for msg identifier but got: ".concat(node.property))}if("Identifier"===node.type){if("self"===node.value)return this.to;this.bindings.hasOwnProperty(node.value)||this.panic("Undefined binding \"".concat(node.value,"\""));const binding=this.bindings[node.value];return new TypedValue(binding.type,binding.value)}}/**
   * Evaluate the entire AST.
   *
   * @return {string}
   */async evaluate(){return this.evaluateNodes(this.ast.body).then(evaluatedNodes=>evaluatedNodes.join(""))}/**
   * Report an error and abort evaluation.
   *
   * @param  {string} msg
   */panic(msg){throw new Error("Error: ".concat(msg))}}/**
 * Evaluates an AST
 *
 * @memberof radspec/evaluator
 * @param {radspec/parser/AST} ast The AST to evaluate
 * @param {radspec/Bindings} bindings An object of bindings and their values
 * @param {?Object} options An options object
 * @param {?string} options.ethNode The URL to an Ethereum node
 * @param {?string} options.to The destination address for this expression's transaction
 * @return {string}
 */exports.Evaluator=Evaluator;function evaluate(ast,bindings,options){return new Evaluator(ast,bindings,options).evaluate()}
//# sourceMappingURL=index.js.map