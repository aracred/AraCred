{"version":3,"sources":["../src/index.js"],"names":["detectProvider","web3","currentProvider","Aragon","constructor","daoAddress","options","defaultOptions","defaultGasPriceFn","provider","cache","forceLocalStorage","events","subscriptionDelayTime","Object","assign","configurationKeys","FORCE_LOCAL_STORAGE","SUBSCRIPTION_EVENT_DELAY","Number","isFinite","subscriptionEventDelay","Web3","ens","apm","ensRegistryAddress","ipfs","apmIpfsOptions","fetchTimeout","ipfsGateway","gateway","kernelProxy","Cache","appContextPool","AppContextPool","init","aclAddress","call","_","Error","updateInitializationBlock","initAccounts","accounts","initAcl","acl","initIdentityProviders","initApps","initForwarders","initAppIdentifiers","initNetwork","initGuiStyle","guiStyle","pathIntents","Subject","transactions","signatures","fetchFromWeb3","providedAccounts","ReplaySubject","concat","eth","getAccounts","setAccounts","aclProxy","initializationBlock","ACL_CACHE_KEY","currentBlock","getBlockNumber","cacheBlockHeight","Math","max","cachedAclState","get","permissions","cachedPermissions","blockNumber","cachedBlockNumber","pastEventsOptions","toBlock","fromBlock","pastEvents$","pastEvents","pipe","event","returnValues","currentEvents$","fetchedPermissions$","eventData","app","appPermissions","key","role","allowedEntitiesSet","Set","dotprop","allowed","add","entity","delete","set","Array","from","manager","connect","cachedPermissions$","isApp","kernelAddress","isKernelAddress","address","applicationInfoCache","AsyncRequestCache","cacheKey","appId","codeAddress","split","fetchLatestRepoContentForContract","resolve","proxyContractValueCache","proxyAddress","Promise","all","then","values","appProxy","appProxyForwarder","catch","isForwarder","installedApps$","keys","oldProxies","newProxies","length","oldSet","intersection","filter","newProxy","has","size","proxyAddresses","appsWithoutKernel","map","proxyValues","request","appProxies","updatedApps$","namespace","setAppEvent","apps","setAppId","updated","updatedApps","apps$","appsWithInfo$","appInfo","isForwarderOverride","isArray","abi","some","type","name","installedRepoCache","Map","repo$","reduce","installedRepos","contractAddress","repos","newRepoAppIds","updatedRepoAppIds","forEach","repo","push","newRepos","repoProxy","repoAddress","err","console","error","update$","newRepo$","repoAddress$","version$","initialVersions","versionId","eventVersionId","timestamp","getBlock","versionIndex","findIndex","versionInfo","versions","newVersionInfo","newVersions","repoUpdate","updatedAppId","update","updatedRepoInfo","updatedRepoAppId","installedRepoInfo","baseRepoInfo","fetchVersionInfo","version","content","latestVersion","currentVersion","reverse","find","currentVersionInfoRequest","latestVersionInfoRequest","updatedRepo","repoIndex","nextRepos","asyncScheduler","leading","trailing","forwarders","appIdentifiers","BehaviorSubject","identifiers","identifier","setAppIdentifier","next","defaultIdentityProviders","LocalIdentityProvider","identityProviders","identityProviderRegistrar","identityIntents","modifyAddressIdentity","metadata","modify","reject","resolveAddressIdentity","searchIdentities","searchTerm","search","requestAddressIdentityModification","providerName","removeLocalIdentities","addresses","localProvider","remove","getLocalIdentities","getAll","appearance","theme","setGuiStyle","network","id","net","getId","getNetworkType","requestAppPath","appAddress","path","getApp","setAppPath","emit","APP_CONTEXTS","PATH","runApp","toPromise","sandboxMessengerProvider","messenger","Messenger","request$","requests","proxy","wrapper","handlerSubscription","handlers","combineRequestHandlers","createRequestHandler","describeScript","describeTransaction","getApps","trigger","web3Eth","intent","signMessage","externalCall","externalEvents","externalIntent","externalPastEvents","appIdentifier","addressIdentity","subscribe","response","sendResponse","payload","shutdown","unsubscribe","shutdownAndClearCache","promise","startsWith","message","requestingApp","performTransactionPath","transactionPath","external","transaction","performACLIntent","method","params","getACLTransactionPath","getTransactionPath","destination","methodSignature","finalForwarder","account","calculateTransactionPath","describeTransactionPath","getExternalTransactionPath","methodJsonDescription","installedApp","tx","getTransactionPathForIntentBasket","intentBasket","checkMode","intentsToCheck","intentPaths","pathsMatch","sender","directTransactions","decoratedTransactions","applyTransactionGas","createForwarderTransaction","forwarderPath","slice","to","nextForwarder","lastStep","encodedLastStep","getPermissionManager","roleHash","aclAddr","functionArtifact","functions","sig","roles","methodABI","item","inputNames","inputs","input","appIndex","indexOf","roleIndex","decodeTransactionPath","script","segment","data","forwardedEvmScript","children","step","decoratedStep","description","processed","annotatedDescription","canForward","forwarder","Contract","methods","getDefaultGasPrice","gasLimit","isForwarding","pretransaction","estimatedGasLimit","estimateGas","gas","recommendedGasLimit","gasPrice","fullMethodSignature","includes","finalForwarderProvided","directTransaction","forwardersWithPermission","destinationPermissions","roleSig","bytes","allowedEntities","ANY_ENTITY","calculateForwardingPath","transactionWithFee","queue","forwarderWithPermission","nextQueue","shift","previousForwarder"],"mappings":"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","sourcesContent":["// Externals\nimport { asyncScheduler, concat, from, merge, of, BehaviorSubject, ReplaySubject, Subject } from 'rxjs'\nimport {\n  concatMap,\n  debounceTime,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  first,\n  map,\n  mergeAll,\n  mergeMap,\n  publishReplay,\n  scan,\n  startWith,\n  switchMap,\n  throttleTime,\n  withLatestFrom\n} from 'rxjs/operators'\nimport Web3 from 'web3'\nimport { isAddress } from 'web3-utils'\nimport dotprop from 'dot-prop'\n\n// RPC\nimport Messenger from '@aragon/rpc-messenger'\nimport * as handlers from './rpc/handlers'\n\nimport AppContextPool, { APP_CONTEXTS } from './apps'\nimport Cache from './cache'\nimport apm, { getApmInternalAppInfo } from './core/apm'\nimport { makeRepoProxy, getAllRepoVersions, getRepoVersionById } from './core/apm/repo'\nimport {\n  getAragonOsInternalAppInfo,\n  isAragonOsInternalApp\n} from './core/aragonOS'\nimport { isKernelAppCodeNamespace } from './core/aragonOS/kernel'\nimport { setConfiguration } from './configuration'\nimport * as configurationKeys from './configuration/keys'\nimport ens from './ens'\nimport { LocalIdentityProvider } from './identity'\nimport { getAbi } from './interfaces'\nimport {\n  postprocessRadspecDescription,\n  tryDescribingUpdateAppIntent,\n  tryDescribingUpgradeOrganizationBasket,\n  tryEvaluatingRadspec\n} from './radspec'\nimport {\n  ANY_ENTITY,\n  addressesEqual,\n  getCacheKey,\n  includesAddress,\n  makeAddressMapProxy,\n  makeProxy,\n  makeProxyFromAppABI,\n  AsyncRequestCache\n} from './utils'\nimport { decodeCallScript, encodeCallScript, isCallScript } from './utils/callscript'\nimport { isValidForwardCall, parseForwardCall } from './utils/forwarding'\nimport { doIntentPathsMatch } from './utils/intents'\nimport {\n  applyForwardingFeePretransaction,\n  createDirectTransaction,\n  createDirectTransactionForApp,\n  createForwarderTransactionBuilder,\n  getRecommendedGasLimit\n} from './utils/transactions'\n\n// Try to get an injected web3 provider, return a public one otherwise.\nexport const detectProvider = () =>\n  typeof web3 !== 'undefined'\n    ? web3.currentProvider // eslint-disable-line\n    : 'wss://rinkeby.eth.aragon.network/ws'\n\n/**\n * An Aragon wrapper.\n *\n * @param {string} daoAddress\n *        The address of the DAO.\n * @param {Object} options\n *        Wrapper options.\n * @param {Object} options.apm\n *        Options for fetching information from aragonPM\n * @param {string} options.apm.ensRegistryAddress\n *        ENS registry for aragonPM\n * @param {Object} [options.apm.ipfs]\n *        IPFS provider config for aragonPM\n * @param {string} [options.apm.ipfs.gateway]\n *        IPFS gateway to fetch aragonPM artifacts from\n * @param {number} [options.apm.ipfs.fetchTimeout]\n *        Timeout for retrieving aragonPM artifacts from IPFS before failing\n * @param {Object} [options.cache]\n *        Options for the internal cache\n * @param {boolean} [options.cache.forceLocalStorage=false]\n *        Downgrade to localStorage even if IndexedDB is available\n * @param {Object} [options.events]\n *        Options for handling Ethereum events\n * @param {boolean} [options.events.subscriptionEventDelay]\n *        Time in ms to delay a new event from a contract subscription\n * @param {Function} [options.defaultGasPriceFn=function]\n *        A factory function to provide the default gas price for transactions.\n *        It can return a promise of number string or a number string. The function\n *        has access to a recommended gas limit which can be used for custom\n *        calculations. This function can also be used to get a good gas price\n *        estimation from a 3rd party resource.\n * @param {string|Object} [options.provider=web3.currentProvider]\n *        The Web3 provider to use for blockchain communication. Defaults to `web3.currentProvider`\n *        if web3 is injected, otherwise will fallback to wss://rinkeby.eth.aragon.network/ws\n */\nexport default class Aragon {\n  constructor (daoAddress, options = {}) {\n    const defaultOptions = {\n      defaultGasPriceFn: () => {},\n      provider: detectProvider(),\n      cache: {\n        forceLocalStorage: false\n      },\n      events: {\n        subscriptionDelayTime: 0\n      }\n    }\n    options = Object.assign(defaultOptions, options)\n\n    // Set up desired configuration\n    setConfiguration(\n      configurationKeys.FORCE_LOCAL_STORAGE,\n      !!(options.cache && options.cache.forceLocalStorage)\n    )\n    setConfiguration(\n      configurationKeys.SUBSCRIPTION_EVENT_DELAY,\n      Number.isFinite(options.events && options.events.subscriptionEventDelay)\n        ? options.events.subscriptionEventDelay\n        : 0\n    )\n\n    // Set up Web3\n    this.web3 = new Web3(options.provider)\n\n    // Set up ENS\n    this.ens = ens(options.provider, options.apm.ensRegistryAddress)\n\n    // Set up APM utilities\n    const { ipfs: apmIpfsOptions = {} } = options.apm\n    this.apm = apm(\n      this.web3,\n      {\n        fetchTimeout: apmIpfsOptions.fetchTimeout,\n        ipfsGateway: apmIpfsOptions.gateway\n      }\n    )\n\n    // Set up the kernel proxy\n    this.kernelProxy = makeProxy(daoAddress, 'Kernel', this.web3)\n\n    // Set up cache\n    this.cache = new Cache(daoAddress)\n\n    // Set up app contexts\n    this.appContextPool = new AppContextPool()\n\n    this.defaultGasPriceFn = options.defaultGasPriceFn\n  }\n\n  /**\n   * Initialise the wrapper.\n   *\n   * @param {Object} [options] Options\n   * @param {Object} [options.accounts] `initAccount()` options (see below)\n   * @param {Object} [options.acl] `initACL()` options (see below)\n   * @param {Object} [options.guiStyle] `initGuiStyle()` options (see below)\n   * @return {Promise<void>}\n   * @throws {Error} Will throw an error if the `daoAddress` is detected to not be a Kernel instance\n   */\n  async init (options = {}) {\n    let aclAddress\n\n    try {\n      // Check if address is kernel\n      // web3 throws if it's an empty address ('0x')\n      aclAddress = await this.kernelProxy.call('acl')\n    } catch (_) {\n      throw Error(`Provided daoAddress is not a DAO`)\n    }\n\n    await this.cache.init()\n    await this.kernelProxy.updateInitializationBlock()\n    await this.initAccounts(options.accounts)\n    await this.initAcl(Object.assign({ aclAddress }, options.acl))\n    await this.initIdentityProviders()\n    this.initApps()\n    this.initForwarders()\n    this.initAppIdentifiers()\n    this.initNetwork()\n    this.initGuiStyle(options.guiStyle)\n    this.pathIntents = new Subject()\n    this.transactions = new Subject()\n    this.signatures = new Subject()\n  }\n\n  /**\n   * Initialise the accounts observable.\n   *\n   * @param {Object} [options] Options\n   * @param {boolean} [options.fetchFromWeb3] Whether or not accounts should also be fetched from\n   *                                          the provided Web3 instance\n   * @param {Array<string>} [options.providedAccounts] Array of accounts that the user controls\n   * @return {Promise<void>}\n   */\n  async initAccounts ({ fetchFromWeb3, providedAccounts = [] } = {}) {\n    this.accounts = new ReplaySubject(1)\n    const accounts = fetchFromWeb3\n      ? providedAccounts.concat(await this.web3.eth.getAccounts())\n      : providedAccounts\n\n    this.setAccounts(accounts)\n  }\n\n  /**\n   * Initialise the ACL (Access Control List).\n   *\n   * @return {Promise<void>}\n   */\n  async initAcl ({ aclAddress } = {}) {\n    if (!aclAddress) {\n      aclAddress = await this.kernelProxy.call('acl')\n    }\n\n    // Set up ACL proxy\n    this.aclProxy = makeProxy(aclAddress, 'ACL', this.web3, { initializationBlock: this.kernelProxy.initializationBlock })\n\n    const SET_PERMISSION_EVENT = 'SetPermission'\n    const CHANGE_PERMISSION_MANAGER_EVENT = 'ChangePermissionManager'\n\n    const ACL_CACHE_KEY = getCacheKey(aclAddress, 'acl')\n\n    const REORG_SAFETY_BLOCK_AGE = 100\n\n    const currentBlock = await this.web3.eth.getBlockNumber()\n    const cacheBlockHeight = Math.max(currentBlock - REORG_SAFETY_BLOCK_AGE, 0) // clamp to 0 for safety\n\n    // Check if we have cached ACL for this address\n    // Cache object for an ACL: { permissions, blockNumber }\n    const cachedAclState = await this.cache.get(ACL_CACHE_KEY, {})\n    const { permissions: cachedPermissions, blockNumber: cachedBlockNumber } = cachedAclState\n\n    const pastEventsOptions = {\n      toBlock: cacheBlockHeight,\n      // When using cache, fetch events from the next block after cache\n      fromBlock: cachedPermissions ? cachedBlockNumber + 1 : undefined\n    }\n    const pastEvents$ = this.aclProxy.pastEvents(null, pastEventsOptions).pipe(\n      mergeMap((pastEvents) => from(pastEvents)),\n      // Custom cache event\n      endWith({\n        event: ACL_CACHE_KEY,\n        returnValues: {}\n      })\n    )\n    const currentEvents$ = this.aclProxy.events(null, { fromBlock: cacheBlockHeight + 1 }).pipe(\n      startWith({\n        event: 'starting current events',\n        returnValues: {}\n      })\n    )\n\n    // Permissions Object:\n    // { app -> role -> { manager, allowedEntities -> [ entities with permission ] } }\n    const fetchedPermissions$ = concat(pastEvents$, currentEvents$).pipe(\n      scan(([permissions], event) => {\n        const eventData = event.returnValues\n\n        if (eventData.app) {\n          // NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions\n          const appPermissions = permissions[eventData.app] || {}\n\n          if (event.event === SET_PERMISSION_EVENT) {\n            const key = `${eventData.role}.allowedEntities`\n\n            // Converts to and from a set to avoid duplicated entities\n            const allowedEntitiesSet = new Set(dotprop.get(appPermissions, key, []))\n\n            if (eventData.allowed) {\n              allowedEntitiesSet.add(eventData.entity)\n            } else {\n              allowedEntitiesSet.delete(eventData.entity)\n            }\n\n            dotprop.set(appPermissions, key, Array.from(allowedEntitiesSet))\n          }\n\n          if (event.event === CHANGE_PERMISSION_MANAGER_EVENT) {\n            // We only care about the last one. An app permission can have only one manager\n            dotprop.set(appPermissions, `${eventData.role}.manager`, eventData.manager)\n          }\n\n          permissions[eventData.app] = appPermissions\n        }\n\n        return [permissions, event]\n      }, [ makeAddressMapProxy(cachedPermissions || {}) ]),\n\n      // Cache if we're finished syncing up to cache block height\n      map(([permissions, event]) => {\n        if (event.event === ACL_CACHE_KEY) {\n          this.cache.set(\n            ACL_CACHE_KEY,\n            // Make copy for cache\n            { permissions: Object.assign({}, permissions), blockNumber: cacheBlockHeight }\n          )\n        }\n        return permissions\n      }),\n\n      // Throttle so it only continues after 30ms without new values\n      // Avoids DDOSing subscribers as during initialization there may be\n      // hundreds of events processed in a short timespan\n      debounceTime(30),\n      publishReplay(1)\n    )\n    fetchedPermissions$.connect()\n\n    const cachedPermissions$ = cachedPermissions ? of(makeAddressMapProxy(cachedPermissions)) : of()\n    this.permissions = concat(cachedPermissions$, fetchedPermissions$).pipe(publishReplay(1))\n    this.permissions.connect()\n  }\n\n  /**\n   * Check if an object is an app.\n   *\n   * @param  {Object}  app\n   * @return {boolean}\n   */\n  isApp (app) {\n    return app.kernelAddress && this.isKernelAddress(app.kernelAddress)\n  }\n\n  /**\n   * Check if an address is this DAO's kernel.\n   *\n   * @param  {string}  address\n   * @return {boolean}\n   */\n  isKernelAddress (address) {\n    return addressesEqual(address, this.kernelProxy.address)\n  }\n\n  /**\n   * Initialize apps observable.\n   *\n   * @return {void}\n   */\n  initApps () {\n    /******************************\n     *                            *\n     *          CACHING           *\n     *                            *\n     ******************************/\n\n    const applicationInfoCache = new AsyncRequestCache(async (cacheKey) => {\n      const [appId, codeAddress] = cacheKey.split('.')\n      return getAragonOsInternalAppInfo(appId) ||\n        getApmInternalAppInfo(appId) ||\n        this.apm.fetchLatestRepoContentForContract(\n          await this.ens.resolve(appId),\n          codeAddress\n        )\n    })\n\n    const proxyContractValueCache = new AsyncRequestCache((proxyAddress) => {\n      if (this.isKernelAddress(proxyAddress)) {\n        const kernelProxy = makeProxy(proxyAddress, 'ERCProxy', this.web3)\n\n        return Promise.all([\n          // Use Kernel ABI\n          this.kernelProxy.call('KERNEL_APP_ID'),\n          // Use ERC897 proxy ABI\n          // Note that this won't work on old Aragon Core 0.5 Kernels,\n          // as they had not implemented ERC897 yet\n          kernelProxy.call('implementation')\n        ]).then((values) => ({\n          appId: values[0],\n          codeAddress: values[1]\n        }))\n      }\n\n      const appProxy = makeProxy(proxyAddress, 'AppProxy', this.web3)\n      const appProxyForwarder = makeProxy(proxyAddress, 'Forwarder', this.web3)\n\n      return Promise.all([\n        appProxy.call('kernel'),\n        appProxy.call('appId'),\n        appProxy.call('implementation'),\n        // Not all apps implement the forwarding interface\n        appProxyForwarder.call('isForwarder').catch(() => false)\n      ]).then((values) => ({\n        kernelAddress: values[0],\n        appId: values[1],\n        codeAddress: values[2],\n        isForwarder: values[3]\n      }))\n    })\n\n    /******************************\n     *                            *\n     *            APPS            *\n     *                            *\n     ******************************/\n\n    // Get all installed app proxy addresses\n    const installedApps$ = this.permissions.pipe(\n      map(Object.keys),\n      // Dedupe until apps change\n      distinctUntilChanged((oldProxies, newProxies) => {\n        if (oldProxies.length !== newProxies.length) {\n          return false\n        }\n        const oldSet = new Set(oldProxies)\n        const intersection = new Set(newProxies.filter(newProxy => oldSet.has(newProxy)))\n        return intersection.size === oldSet.size\n      }),\n      // Add Kernel as the first \"app\"\n      map((proxyAddresses) => {\n        const appsWithoutKernel = proxyAddresses.filter((address) => !this.isKernelAddress(address))\n        return [this.kernelProxy.address].concat(appsWithoutKernel)\n      }),\n      // Get proxy values\n      // Note that we can safely discard throttled values,\n      // so we use a `switchMap()` instead of a `mergeMap()`\n      switchMap(\n        (proxyAddresses) => Promise.all(\n          proxyAddresses.map(async (proxyAddress) => {\n            let proxyValues\n            try {\n              proxyValues = await proxyContractValueCache.request(proxyAddress)\n            } catch (_) {}\n\n            return {\n              proxyAddress,\n              ...proxyValues\n            }\n          })\n        )\n      ),\n      // Filter to remove any non-apps assigned in permissions\n      map(appProxies => appProxies.filter(\n        (appProxy) => this.isApp(appProxy) || this.isKernelAddress(appProxy.proxyAddress)\n      ))\n    )\n\n    // SetApp events are emitted when apps are installed and upgraded\n    // These may modify the implementation addresses of the proxies (modifying their behaviour), so\n    // we invalidate any caching we've done\n    const updatedApps$ = this.kernelProxy\n      // Only need to subscribe from latest block\n      .events('SetApp', { fromBlock: 'latest' })\n      .pipe(\n        // Only care about changes if they're in the APP_BASE namespace\n        filter(({ returnValues }) => isKernelAppCodeNamespace(returnValues.namespace)),\n\n        // Merge with latest value of installedApps$ so we can return the full list of apps\n        withLatestFrom(\n          installedApps$,\n          function updateApps (setAppEvent, apps) {\n            const { appId: setAppId } = setAppEvent.returnValues\n            return apps.map(async (app) => {\n              if (app.appId !== setAppId) {\n                return app\n              }\n\n              let proxyValues\n              try {\n                proxyValues = await proxyContractValueCache.request(\n                  app.proxyAddress,\n                  true // force cache invalidation\n                )\n              } catch (_) {}\n\n              return {\n                ...app,\n                ...proxyValues,\n                updated: true\n              }\n            })\n          }\n        ),\n        // Emit resolved array of promises, one at a time\n        concatMap(updatedApps => Promise.all(updatedApps))\n      )\n\n    // We merge these two observables, which both return the full list of apps attached with their\n    // proxy values:\n    //   - installedApps$: emits any time the list of installed apps changes\n    //   - updatedApps$:   emits any time SetApp could modify an installed app\n    const apps$ = merge(installedApps$, updatedApps$)\n\n    // Get artifact info for apps\n    const appsWithInfo$ = apps$.pipe(\n      concatMap(\n        (apps) => Promise.all(\n          apps.map(async (app) => {\n            let appInfo\n            if (app.appId && app.codeAddress) {\n              const cacheKey = `${app.appId}.${app.codeAddress}`\n              try {\n                appInfo = await applicationInfoCache.request(cacheKey)\n              } catch (_) { }\n            }\n\n            // This is a hack to fix web3.js and ethers not being able to detect reverts on decoding\n            // `eth_call`s (apps that implement fallbacks may revert if they haven't defined\n            // `isForwarder()`)\n            // Ideally web3.js would throw an error if it receives a revert from an `eth_call`, but\n            // as of v1.2.1, it interprets reverts as `true` :(.\n            //\n            // We check if the app's ABI actually has `isForwarder()` declared, and if not, override\n            // the isForwarder setting to false.\n            let isForwarderOverride = {}\n            if (\n              app.isForwarder &&\n              appInfo &&\n              Array.isArray(appInfo.abi) &&\n              !appInfo.abi.some(({ type, name }) => type === 'function' && name === 'isForwarder')\n            ) {\n              isForwarderOverride = {\n                isForwarder: false\n              }\n            }\n\n            return {\n              ...appInfo,\n              // Override the fetched appInfo with the actual app proxy's values to avoid mismatches\n              ...app,\n              // isForwarder override (see above)\n              ...isForwarderOverride\n            }\n          })\n        )\n      )\n    )\n\n    this.apps = appsWithInfo$.pipe(\n      publishReplay(1)\n    )\n    this.apps.connect()\n\n    /*******************************\n     *                             *\n     *            REPOS            *\n     *                             *\n     ******************************/\n\n    // Initialize installed repos from the list of apps\n    const installedRepoCache = new Map()\n    const repo$ = apps$.pipe(\n      // Map installed apps into a deduped list of their aragonPM repos, with these assumptions:\n      //   - No apps are lying about their appId (malicious apps _could_ masquerade as other\n      //     apps by setting this value themselves)\n      //   - `contractAddress`s will stay the same across all installed apps.\n      //     This is technically not true as apps could set this value themselves\n      //     (e.g. as pinned apps do), but these apps wouldn't be able to upgrade anyway\n      //\n      //  Ultimately returns an array of objects, holding the repo's:\n      //    - appId\n      //    - base contractAddress\n      map((apps) => Object.values(\n        apps\n          .filter(({ appId }) => !isAragonOsInternalApp(appId))\n          .reduce((installedRepos, { appId, codeAddress, updated }) => {\n            installedRepos[appId] = {\n              appId,\n              updated,\n              contractAddress: codeAddress\n            }\n            return installedRepos\n          }, {})\n      )),\n\n      // Filter list of installed repos into:\n      //   - New repos we haven't seen before (to begin subscribing to their version events)\n      //   - Repos we've seen before, to trigger a recalculation of the currently installed version\n      map((repos) => {\n        const newRepoAppIds = []\n        const updatedRepoAppIds = []\n\n        repos.forEach((repo) => {\n          const { appId, updated } = repo\n          if (!installedRepoCache.has(appId)) {\n            newRepoAppIds.push(appId)\n          } else if (updated) {\n            updatedRepoAppIds.push(appId)\n          }\n\n          // Mark repo as seen and cache installed information\n          installedRepoCache.set(appId, repo)\n        })\n\n        return [newRepoAppIds, updatedRepoAppIds]\n      }),\n\n      // Stop if there's no new repos or updated apps\n      filter(([newRepoAppIds, updatedRepoAppIds]) =>\n        newRepoAppIds.length || updatedRepoAppIds.length\n      ),\n\n      // Project new repos into their ids and web3 proxy objects\n      concatMap(async ([newRepoAppIds, updatedRepoAppIds]) => {\n        const newRepos = (await Promise.all(\n          newRepoAppIds.map(async (appId) => {\n            let repoProxy\n\n            try {\n              const repoAddress = await this.ens.resolve(appId)\n              repoProxy = makeRepoProxy(repoAddress, this.web3)\n              await repoProxy.updateInitializationBlock()\n            } catch (err) {\n              console.error(`Could not find repo for ${appId}`, err)\n            }\n\n            return {\n              appId,\n              repoProxy\n            }\n          })\n        ))\n          // Filter out repos we couldn't create proxies for (they were likely due to publishing\n          // invalid aragonPM repos)\n          // Note that we don't need to worry about doing this for the updated repos list; if\n          // we could not create the original repo proxy when we first saw the repo, the updates\n          // won't do anything because we weren't able to fetch enough information (versions list)\n          .filter((newRepos) => newRepos.repoProxy)\n        return [newRepos, updatedRepoAppIds]\n      }),\n\n      // Here's where the fun begins!\n      // It'll be easy to get lost, so remember to take it slowly.\n      // Just remember, with this `mergeMap()`, we'll be subscribing to all the projected (returned)\n      // observables and merging their respective emissions into a single observable.\n      //\n      // The output of this merged observable are update events containing the following:\n      //   - `appId`: mandatory, signifies which repo was updated\n      //   - `repoAddress`: optional, address of the repo contract itself\n      //   - `versions`: optional, new version information\n      mergeMap(([newRepos, updatedRepoAppIds]) => {\n        // Create a new observable to project each new update as its own update emission.\n        const update$ = of(...updatedRepoAppIds).pipe(\n          map((appId) => ({ appId }))\n        )\n\n        // Create a new observable to project each new repo as its own emission.\n        const newRepo$ = of(...newRepos)\n\n        // Create a new observable to project each new repo's address as its own update emission.\n        const repoAddress$ = newRepo$.pipe(\n          map(({ appId, repoProxy }) => ({\n            appId,\n            repoAddress: repoProxy.address\n          }))\n        )\n\n        // Create a new observable that projects each NewVersion event as its own update event\n        // emission.\n        // This one is a bit trickier, due to the higher order observable. Keep reading.\n        const version$ = newRepo$.pipe(\n          // `mergeMap()` to \"flatten\" the async transformation. This async function returns an\n          // observable, which is ultimately the NewVersion stream. More on this, after the break.\n          // Note: we don't care about the ordering, so we use `mergeMap()` instead of `concatMap()`\n          mergeMap(async ({ appId, repoProxy }) => {\n            const initialVersions = [\n              // Immediately query state from the repo contract, to avoid having to wait until all\n              // past events sync (may be long)\n              ...await getAllRepoVersions(repoProxy)\n            ]\n\n            // Return an observable subscribed to NewVersion events, giving us:\n            //   - Timestamps for versions that were published prior to this process running\n            //   - Notifications for newly published versions\n            //\n            // Reduce this with the cached version information to emit version updates for the repo.\n            return repoProxy.events('NewVersion').pipe(\n              // Project each event to a new version info object, one at a time\n              concatMap(async (event) => {\n                const { versionId: eventVersionId } = event.returnValues\n\n                // Adjust from Ethereum time\n                const timestamp = (await this.web3.eth.getBlock(event.blockNumber)).timestamp * 1000\n\n                const versionIndex = initialVersions.findIndex(({ versionId }) => versionId === eventVersionId)\n                const versionInfo =\n                  versionIndex === -1\n                    ? await getRepoVersionById(repoProxy, eventVersionId)\n                    : initialVersions[versionIndex]\n\n                return {\n                  ...versionInfo,\n                  timestamp\n                }\n              }),\n\n              // Trick to immediately emit (e.g. similar to a do/while loop)\n              startWith(null),\n\n              // Reduce newly emitted versions into the full list of versions\n              scan(({ appId, versions }, newVersionInfo) => {\n                let newVersions = versions\n                if (newVersionInfo) {\n                  const versionIndex = versions.findIndex(({ versionId }) => versionId === newVersionInfo.versionId)\n\n                  if (versionIndex === -1) {\n                    newVersions = versions.concat(newVersionInfo)\n                  } else {\n                    newVersions = Array.from(versions)\n                    newVersions[versionIndex] = newVersionInfo\n                  }\n                }\n\n                return {\n                  appId,\n                  versions: newVersions\n                }\n              }, {\n                appId,\n                versions: initialVersions\n              })\n            )\n          }),\n\n          // This bit is interesting.\n          // We've \"flattened\" our async transformation with the `mergeMap()` above, but it still\n          // returns an observable. We need to flatten this observable's emissions into the upper\n          // stream, which is what `mergeAll()` achieves.\n          mergeAll()\n        )\n\n        // Merge all of the repo update events resulting from the apps being updated, and return it\n        // to the upper `mergeMap()` so it can be re-flattened into a single event stream.\n        return merge(repoAddress$, version$, update$)\n      }),\n\n      // Reduce the event stream into a current representation of the installed repos, and which\n      // repo to update next.\n      scan(({ repos }, repoUpdate) => {\n        const { appId: updatedAppId, ...update } = repoUpdate\n        const updatedRepoInfo = {\n          ...repos[updatedAppId],\n          ...update\n        }\n\n        return {\n          repos: {\n            ...repos,\n            [updatedAppId]: updatedRepoInfo\n          },\n          updatedRepoAppId: updatedAppId\n        }\n      }, {\n        repos: {},\n        updatedRepoAppId: null\n      }),\n\n      // Stop if we don't have enough information yet to continue\n      filter(({ repos, updatedRepoAppId }) =>\n        !!updatedRepoAppId && Array.isArray(repos[updatedRepoAppId].versions)\n      ),\n\n      // Grab the full information of the updated repo using its latest values.\n      // With this, we've taken the basic stream of updates for events and mapped them onto their\n      // full repo objects.\n      concatMap(async ({ repos, updatedRepoAppId: appId }) => {\n        const { repoAddress, versions } = repos[appId]\n        const installedRepoInfo = installedRepoCache.get(appId)\n\n        const baseRepoInfo = { appId, repoAddress, versions }\n        const fetchVersionInfo = version => {\n          return applicationInfoCache\n            .request(`${appId}.${version.contractAddress}`)\n            .catch(() => ({}))\n            .then(content => ({\n              content,\n              version: version.version\n            }))\n        }\n\n        const latestVersion = versions[versions.length - 1]\n        const currentVersion = Array.from(versions)\n          // Apply reverse to find the latest version with the currently installed contract address\n          .reverse()\n          .find(version => addressesEqual(version.contractAddress, installedRepoInfo.contractAddress))\n\n        if (!currentVersion) {\n          // The organization has installed an unpublished version of this app\n          // Avoid returning a current version as we don't know what version they're using\n          return {\n            ...baseRepoInfo,\n            currentVersion: null,\n            latestVersion: await fetchVersionInfo(latestVersion)\n          }\n        }\n\n        const currentVersionInfoRequest = fetchVersionInfo(currentVersion)\n        const latestVersionInfoRequest =\n          addressesEqual(currentVersion.contractAddress, latestVersion.contractAddress)\n            ? currentVersionInfoRequest\n            : fetchVersionInfo(latestVersion)\n\n        return {\n          ...baseRepoInfo,\n          currentVersion: await currentVersionInfoRequest,\n          latestVersion: await latestVersionInfoRequest\n        }\n      })\n    )\n\n    this.installedRepos = repo$.pipe(\n      // Finally, we reduce the merged updates from individual repos into one final, expanding array\n      // of the installed repos\n      scan((repos, updatedRepo) => {\n        const repoIndex = repos.findIndex(repo => repo.repoAddress === updatedRepo.repoAddress)\n        if (repoIndex === -1) {\n          return repos.concat(updatedRepo)\n        } else {\n          const nextRepos = Array.from(repos)\n          nextRepos[repoIndex] = updatedRepo\n          return nextRepos\n        }\n      }, []),\n      // Throttle updates, but must keep trailing to ensure we don't drop any updates\n      throttleTime(500, asyncScheduler, { leading: false, trailing: true }),\n      publishReplay(1)\n    )\n    this.installedRepos.connect()\n  }\n\n  /**\n   * Initialise forwarder observable.\n   *\n   * @return {void}\n   */\n  initForwarders () {\n    this.forwarders = this.apps.pipe(\n      map(\n        (apps) => apps.filter((app) => app.isForwarder)\n      ),\n      publishReplay(1)\n    )\n    this.forwarders.connect()\n  }\n\n  /**\n   * Initialise app identifier observable.\n   *\n   * @return {void}\n   */\n  initAppIdentifiers () {\n    this.appIdentifiers = new BehaviorSubject({}).pipe(\n      scan(\n        (identifiers, { address, identifier }) =>\n          Object.assign(identifiers, { [address]: identifier })\n      ),\n      publishReplay(1)\n    )\n    this.appIdentifiers.connect()\n  }\n\n  /**\n   * Set the identifier of an app.\n   *\n   * @param {string} address The proxy address of the app\n   * @param {string} identifier The identifier of the app\n   * @return {void}\n   */\n  setAppIdentifier (address, identifier) {\n    this.appIdentifiers.next({\n      address,\n      identifier\n    })\n  }\n\n  /**\n   * Initialise identity providers.\n   *\n   * @return {Promise<void>}\n   */\n  async initIdentityProviders () {\n    const defaultIdentityProviders = [{\n      name: 'local',\n      provider: new LocalIdentityProvider()\n    }]\n    // TODO: detect other installed providers\n    const detectedIdentityProviders = []\n    const identityProviders = [...defaultIdentityProviders, ...detectedIdentityProviders]\n\n    // Init all providers\n    await Promise.all(identityProviders.map(({ provider }) => {\n      // Most providers should have this defined to a noop function by default, but just in case\n      if (typeof provider.init === 'function') {\n        return provider.init()\n      }\n      return Promise.resolve()\n    }))\n\n    this.identityProviderRegistrar = new Map(\n      identityProviders.map(({ name, provider }) => [name, provider])\n    )\n    // Set up identity modification intent observable\n    this.identityIntents = new Subject()\n  }\n\n  /**\n   * Modify the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to modify\n   * @param  {Object} metadata Modification metadata object\n   * @return {Promise} Resolves if the modification was successful\n   */\n  modifyAddressIdentity (address, metadata) {\n    const providerName = 'local'\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.modify === 'function') {\n      return provider.modify(address, metadata)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Resolve the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  resolveAddressIdentity (address) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.resolve === 'function') {\n      return provider.resolve(address)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Search identities based on a term\n   *\n   * @param  {string} searchTerm\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  searchIdentities (searchTerm) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.search === 'function') {\n      return provider.search(searchTerm)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Request an identity modification using the highest priority provider.\n   *\n   * Returns a promise which delegates resolution to the handler\n   * which listens and handles `this.identityIntents`\n   *\n   * @param  {string} address Address to modify\n   * @return {Promise} Resolved by the handler of identityIntents\n   */\n  requestAddressIdentityModification (address) {\n    const providerName = 'local' // TODO - get provider\n    if (this.identityProviderRegistrar.has(providerName)) {\n      return new Promise((resolve, reject) => {\n        this.identityIntents.next({\n          address,\n          providerName,\n          resolve,\n          reject (err) {\n            reject(err || new Error('The identity modification was not completed'))\n          }\n        })\n      })\n    }\n\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Remove selected local identities\n   *\n   * @param {Array<string>} addresses The addresses to be removed from the local identity provider\n   * @return {Promise}\n   */\n  async removeLocalIdentities (addresses) {\n    const localProvider = this.identityProviderRegistrar.get('local')\n    for (const address of addresses) {\n      await localProvider.remove(address)\n    }\n  }\n\n  /**\n   * Get all local identities for listing functionality\n   *\n   * @return {Promise<Object>}\n   */\n  getLocalIdentities () {\n    return this.identityProviderRegistrar.get('local').getAll()\n  }\n\n  /**\n   * Initialise the GUI style observable.\n   *\n   * @param {Object} style GUI style options\n   * @param {string} style.appearance \"dark\" or \"light\"\n   * @param {Object} [style.theme] The theme object\n   * @return {void}\n   */\n  initGuiStyle ({ appearance, theme } = {}) {\n    this.guiStyle = new BehaviorSubject({\n      appearance: appearance || 'light',\n      theme: theme || null\n    })\n  }\n\n  /**\n   * Set the GUI style (theme and appearance).\n   *\n   * @param {string} appearance \"dark\" or \"light\"\n   * @param {Object} [theme] The theme object.\n   * @return {void}\n   */\n  setGuiStyle (appearance, theme = null) {\n    this.guiStyle.next({\n      appearance,\n      theme\n    })\n  }\n\n  /**\n   * Initialise the network observable.\n   *\n   * @return {Promise<void>}\n   */\n  async initNetwork () {\n    this.network = new ReplaySubject(1)\n    this.network.next({\n      id: await this.web3.eth.net.getId(),\n      type: await this.web3.eth.net.getNetworkType()\n    })\n  }\n\n  /**\n   * Request an app's path be changed.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {Promise} Succeeds if path request was allowed\n   */\n  async requestAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    if (!await this.getApp(appAddress)) {\n      throw new Error(`Cannot request path for non-installed app: ${appAddress}`)\n    }\n\n    return new Promise((resolve, reject) => {\n      this.pathIntents.next({\n        appAddress,\n        path,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The path was rejected'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Set an app's path.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {void}\n   */\n  setAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    this.appContextPool.emit(appAddress, APP_CONTEXTS.PATH, path)\n  }\n\n  /**\n   * Run an app.\n   *\n   * As there may be race conditions with losing messages from cross-context environments,\n   * running an app is split up into two parts:\n   *\n   *   1. Set up any required state for the app. This step is allowed to be asynchronous.\n   *   2. Connect the app to a running context, by associating the context's message provider\n   *      to the app. This step is synchronous.\n   *\n   * @param  {string} proxyAddress\n   *         The address of the app proxy.\n   * @return {Promise<function>}\n   */\n  async runApp (proxyAddress) {\n    // Step 1: Set up required state for the app\n\n    // Only get the first result from the observable, so our running contexts don't get\n    // reinitialized if new apps appear\n    const apps = await this.apps.pipe(first()).toPromise()\n\n    const app = apps.find((app) => addressesEqual(app.proxyAddress, proxyAddress))\n\n    // TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw\n    const appProxy = makeProxyFromAppABI(app.proxyAddress, app.abi, this.web3)\n\n    await appProxy.updateInitializationBlock()\n\n    // Step 2: Associate app with running context\n    return (sandboxMessengerProvider) => {\n      // Set up messenger\n      const messenger = new Messenger(\n        sandboxMessengerProvider\n      )\n\n      // Wrap requests with the application proxy\n      // Note that we have to do this synchronously with the creation of the message provider,\n      // as we otherwise risk race conditions and may lose messages\n      const request$ = messenger.requests().pipe(\n        map(request => ({ request, proxy: appProxy, wrapper: this })),\n        // Use the same request$ result in each handler\n        // Turns request$ into a subject\n        publishReplay(1)\n      )\n      request$.connect()\n\n      // Register request handlers\n      const handlerSubscription = handlers.combineRequestHandlers(\n        // Generic handlers\n        handlers.createRequestHandler(request$, 'accounts', handlers.accounts),\n        handlers.createRequestHandler(request$, 'cache', handlers.cache),\n        handlers.createRequestHandler(request$, 'describe_script', handlers.describeScript),\n        handlers.createRequestHandler(request$, 'describe_transaction', handlers.describeTransaction),\n        handlers.createRequestHandler(request$, 'get_apps', handlers.getApps),\n        handlers.createRequestHandler(request$, 'network', handlers.network),\n        handlers.createRequestHandler(request$, 'path', handlers.path),\n        handlers.createRequestHandler(request$, 'gui_style', handlers.guiStyle),\n        handlers.createRequestHandler(request$, 'trigger', handlers.trigger),\n        handlers.createRequestHandler(request$, 'web3_eth', handlers.web3Eth),\n\n        // Contract handlers\n        handlers.createRequestHandler(request$, 'intent', handlers.intent),\n        handlers.createRequestHandler(request$, 'call', handlers.call),\n        handlers.createRequestHandler(request$, 'sign_message', handlers.signMessage),\n        handlers.createRequestHandler(request$, 'events', handlers.events),\n        handlers.createRequestHandler(request$, 'past_events', handlers.pastEvents),\n\n        // External contract handlers\n        handlers.createRequestHandler(request$, 'external_call', handlers.externalCall),\n        handlers.createRequestHandler(request$, 'external_events', handlers.externalEvents),\n        handlers.createRequestHandler(request$, 'external_intent', handlers.externalIntent),\n        handlers.createRequestHandler(request$, 'external_past_events', handlers.externalPastEvents),\n\n        // Identity handlers\n        handlers.createRequestHandler(request$, 'identify', handlers.appIdentifier),\n        handlers.createRequestHandler(request$, 'address_identity', handlers.addressIdentity),\n        handlers.createRequestHandler(request$, 'search_identities', handlers.searchIdentities)\n      ).subscribe(\n        (response) => messenger.sendResponse(response.id, response.payload)\n      )\n\n      // The attached unsubscribe isn't automatically bound to the subscription\n      const shutdown = () => handlerSubscription.unsubscribe()\n\n      const shutdownAndClearCache = async () => {\n        shutdown()\n\n        // Remove all cache keys related to this app one by one\n        return Object\n          .keys(await this.cache.getAll())\n          .reduce((promise, cacheKey) => {\n            return promise.then(() =>\n              cacheKey.startsWith(proxyAddress)\n                ? this.cache.remove(cacheKey)\n                : Promise.resolve()\n            )\n          }, Promise.resolve())\n      }\n\n      return {\n        shutdown,\n        shutdownAndClearCache\n      }\n    }\n  }\n\n  /**\n   * Set the available accounts for the current user.\n   *\n   * @param {Array<string>} accounts\n   * @return {void}\n   */\n  setAccounts (accounts) {\n    this.accounts.next(accounts)\n  }\n\n  /**\n   * Get the available accounts for the current user.\n   *\n   * @return {Promise<Array<string>>} An array of addresses\n   */\n  getAccounts () {\n    return this.accounts.pipe(first()).toPromise()\n  }\n\n  /**\n   * Allows apps to sign arbitrary data via a RPC call\n   *\n   * @param {string} message to be signed\n   * @param {string} requestingApp proxy address of requesting app\n   * @return {Promise<string>} signature hash\n   */\n  signMessage (message, requestingApp) {\n    if (typeof message !== 'string') {\n      return Promise.reject(new Error('Message to sign must be a string'))\n    }\n    return new Promise((resolve, reject) => {\n      this.signatures.next({\n        message,\n        requestingApp,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The message was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each\n   *   step in the path\n   * @param {Object} [options]\n   * @param {boolean} [options.external] Whether the transaction path is initiating an action on\n   *   an external destination (not the currently running app)\n   * @return {Promise<string>} Promise that should be resolved with the sent transaction hash\n   */\n  performTransactionPath (transactionPath, { external } = {}) {\n    return new Promise((resolve, reject) => {\n      this.transactions.next({\n        resolve,\n        external: !!external,\n        transaction: transactionPath[0],\n        path: transactionPath,\n        reject (err) {\n          reject(err || new Error('The transaction was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Performs an action on the ACL using transaction pathing\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<string>} transaction hash\n   */\n  async performACLIntent (method, params) {\n    const path = await this.getACLTransactionPath(method, params)\n    return this.performTransactionPath(path)\n  }\n\n  /**\n   * Looks for app with the provided proxyAddress and returns its app object if found\n   *\n   * @param {string} proxyAddress\n   * @return {Promise<Object>} The app object\n   */\n  getApp (proxyAddress) {\n    return this.apps.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getTransactionPath (destination, methodSignature, params, finalForwarder) {\n    const accounts = await this.getAccounts()\n\n    for (let account of accounts) {\n      const path = await this.calculateTransactionPath(\n        account,\n        destination,\n        methodSignature,\n        params,\n        finalForwarder\n      )\n\n      if (path.length > 0) {\n        try {\n          return this.describeTransactionPath(path)\n        } catch (_) {\n          return path\n        }\n      }\n    }\n\n    return []\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to an external `destination`\n   * (not the currently running app) that invokes a method matching the\n   * `methodJsonDescription` with `params`.\n   *\n   * @param  {string} destination Address of the external contract\n   * @param  {object} methodJsonDescription ABI description of method to invoke\n   * @param  {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path.\n   *   If the destination is a non-installed contract, always results in an array containing a\n   *   single transaction.\n   */\n  async getExternalTransactionPath (destination, methodJsonDescription, params) {\n    let path\n\n    const installedApp = await this.getApp(destination)\n    if (installedApp) {\n      // Destination is an installed app; need to go through normal transaction pathing\n      path = this.getTransactionPath(destination, methodJsonDescription.name, params)\n    } else {\n      // Destination is not an installed app on this org, just create a direct transaction\n      // with the first account\n      const account = (await this.getAccounts())[0]\n\n      try {\n        const tx = await createDirectTransaction(account, destination, methodJsonDescription, params, this.web3)\n        path = this.describeTransactionPath([tx])\n      } catch (_) {}\n    }\n\n    return path || []\n  }\n\n  /**\n   * Calculate the transaction path for a basket of intents.\n   * Expects the `intentBasket` to be an array of tuples holding the following:\n   *   {string}   destination: destination address\n   *   {string}   methodSignature: method to invoke on destination\n   *   {Array<*>} params: method params\n   * These are the same parameters as the ones used for `getTransactionPath()`\n   *\n   * Allows user to specify how many of the intents should be checked to ensure their paths are\n   * compatible. `checkMode` supports:\n   *   'all': All intents will be checked to make sure they use the same forwarding path.\n   *   'single': assumes all intents can use the path found from the first intent\n   *\n   * @param  {Array<Array<string, string, Array<*>>>} intentBasket Intents\n   * @param  {Object} [options]\n   * @param  {string} [options.checkMode] Path checking mode\n   * @return {Promise<Object>} An object containing:\n   *   - `path` (Array<Object>): a multi-step transaction path that eventually invokes this basket.\n   *     Empty if no such path could be found.\n   *   - `transactions` (Array<Object>): array of Ethereum transactions that invokes this basket.\n   *     If a multi-step transaction path was found, returns the first transaction in that path.\n   *     Empty if no such transactions could be found.\n   */\n  async getTransactionPathForIntentBasket (intentBasket, { checkMode = 'all' } = {}) {\n    // Get transaction paths for entire basket\n    const intentsToCheck =\n      checkMode === 'all'\n        ? intentBasket // all -- use all intents\n        : checkMode === 'single'\n          ? [intentBasket[0]] // single -- only use first intent\n          : []\n    const intentPaths = await Promise.all(\n      intentsToCheck.map(\n        ([destination, methodSignature, params]) =>\n          addressesEqual(destination, this.aclProxy.address)\n            ? this.getACLTransactionPath(methodSignature, params)\n            : this.getTransactionPath(destination, methodSignature, params)\n      )\n    )\n\n    // If the paths don't match, we can't send the transactions in this intent basket together\n    const pathsMatch = doIntentPathsMatch(intentPaths)\n    if (pathsMatch) {\n      // Create direct transactions for each intent in the intentBasket\n      const sender = (await this.getAccounts())[0] // TODO: don't assume it's the first account\n      const directTransactions = await Promise.all(\n        intentBasket.map(\n          async ([destination, methodSignature, params]) =>\n            createDirectTransactionForApp(sender, await this.getApp(destination), methodSignature, params, this.web3)\n        )\n      )\n\n      if (intentPaths[0].length === 1) {\n        // Sender has direct access\n        try {\n          const decoratedTransactions = await this.describeTransactionPath(\n            await Promise.all(\n              directTransactions.map(transaction => this.applyTransactionGas(transaction))\n            )\n          )\n\n          return {\n            path: [],\n            transactions: decoratedTransactions\n          }\n        } catch (_) { }\n      } else {\n        // Need to encode calls scripts for each forwarder transaction in the path\n        const createForwarderTransaction = createForwarderTransactionBuilder(sender, {}, this.web3)\n        const forwarderPath = intentPaths[0]\n          // Ignore the last part of the path, which was the original intent\n          .slice(0, -1)\n          // Start from the \"last\" forwarder and move backwards to the sender\n          .reverse()\n          // Just use the forwarders' addresses\n          .map(({ to }) => to)\n          .reduce(\n            (path, nextForwarder) => {\n              const lastStep = path[0]\n              const encodedLastStep = encodeCallScript(Array.isArray(lastStep) ? lastStep : [lastStep])\n              return [createForwarderTransaction(nextForwarder, encodedLastStep), ...path]\n            },\n            // Start the recursive calls script encoding with the direct transactions for the\n            // intent basket\n            [directTransactions]\n          )\n\n        try {\n          // Put the finishing touches: apply gas, and add radspec descriptions\n          forwarderPath[0] = await this.applyTransactionGas(forwarderPath[0], true)\n          return {\n            path: await this.describeTransactionPath(forwarderPath),\n            // When we have a path, we only need to send the first transaction to start it\n            transactions: [forwarderPath[0]]\n          }\n        } catch (_) { }\n      }\n    }\n\n    // Failed to find a path\n    return {\n      path: [],\n      transactions: []\n    }\n  }\n\n  /**\n   * Get the permission manager for an `app`'s and `role`.\n   *\n   * @param {string} appAddress\n   * @param {string} roleHash\n   * @return {Promise<string>} The permission manager\n   */\n  async getPermissionManager (appAddress, roleHash) {\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const appPermissions = permissions[appAddress]\n\n    return dotprop.get(appPermissions, `${roleHash}.manager`)\n  }\n\n  /**\n   * Calculates transaction path for performing a method on the ACL\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getACLTransactionPath (method, params) {\n    const aclAddr = this.aclProxy.address\n\n    const acl = await this.getApp(aclAddr)\n\n    const functionArtifact = acl.functions.find(\n      ({ sig }) => sig.split('(')[0] === method\n    )\n\n    if (!functionArtifact) {\n      throw new Error(`Method ${method} not found on ACL artifact`)\n    }\n\n    if (functionArtifact.roles && functionArtifact.roles.length !== 0) {\n      // createPermission can be done with regular transaction pathing (it has a regular ACL role)\n      return this.getTransactionPath(aclAddr, method, params)\n    } else {\n      // All other ACL functions don't have a role, the manager needs to be provided to aid transaction pathing\n\n      // Inspect ABI to find the position of the 'app' and 'role' parameters needed to get the permission manager\n      const methodABI = acl.abi.find(\n        (item) => item.name === method && item.type === 'function'\n      )\n\n      if (!methodABI) {\n        throw new Error(`Method ${method} not found on ACL ABI`)\n      }\n\n      const inputNames = methodABI.inputs.map((input) => input.name)\n      const appIndex = inputNames.indexOf('_app')\n      const roleIndex = inputNames.indexOf('_role')\n\n      if (appIndex === -1 || roleIndex === -1) {\n        throw new Error(`Method ${method} doesn't take _app and _role as input. Permission manager cannot be found.`)\n      }\n\n      const manager = await this.getPermissionManager(params[appIndex], params[roleIndex])\n\n      return this.getTransactionPath(aclAddr, method, params, manager)\n    }\n  }\n\n  /**\n   * Decodes an EVM callscript and returns the transaction path it describes.\n   *\n   * @param  {string} script\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  decodeTransactionPath (script) {\n    // In the future we may support more EVMScripts, but for now let's just assume we're only\n    // dealing with call scripts\n    if (!isCallScript(script)) {\n      throw new Error(`Script could not be decoded: ${script}`)\n    }\n\n    const path = decodeCallScript(script)\n    return path.map((segment) => {\n      const { data } = segment\n\n      if (isValidForwardCall(data)) {\n        const forwardedEvmScript = parseForwardCall(data)\n\n        try {\n          segment.children = this.decodeTransactionPath(forwardedEvmScript)\n        } catch (err) {}\n      }\n\n      return segment\n    })\n  }\n\n  /**\n   * Use radspec to create a human-readable description for each transaction in the given `path`\n   *\n   * @param  {Array<Object>} path\n   * @return {Promise<Array<Object>>} The given `path`, with decorated with descriptions at each step\n   */\n  async describeTransactionPath (path) {\n    return Promise.all(path.map(async (step) => {\n      let decoratedStep\n\n      if (Array.isArray(step)) {\n        // Intent basket with multiple transactions in a single callscript\n        // First see if the step can be handled with a specialized descriptor\n        try {\n          decoratedStep = await tryDescribingUpgradeOrganizationBasket(step, this)\n        } catch (err) { }\n\n        // If the step wasn't handled, just individually describe each of the transactions\n        return decoratedStep || this.describeTransactionPath(step)\n      }\n\n      // Single transaction step\n      // First see if the step can be handled with a specialized descriptor\n      try {\n        decoratedStep = await tryDescribingUpdateAppIntent(step, this)\n      } catch (err) { }\n\n      // Finally, if the step wasn't handled yet, evaluate via radspec normally\n      if (!decoratedStep) {\n        try {\n          decoratedStep = await tryEvaluatingRadspec(step, this)\n        } catch (err) { }\n      }\n\n      // Annotate the description, if one was found\n      if (decoratedStep) {\n        if (decoratedStep.description) {\n          try {\n            const processed = await postprocessRadspecDescription(decoratedStep.description, this)\n            decoratedStep.description = processed.description\n            decoratedStep.annotatedDescription = processed.annotatedDescription\n          } catch (err) { }\n        }\n\n        if (decoratedStep.children) {\n          decoratedStep.children = await this.describeTransactionPath(decoratedStep.children)\n        }\n      }\n\n      return decoratedStep || step\n    }))\n  }\n\n  /**\n   * Whether the `sender` can use the `forwarder` to invoke `script`.\n   *\n   * @param  {string} forwarder\n   * @param  {string} sender\n   * @param  {string} script\n   * @return {Promise<bool>}\n   */\n  canForward (forwarder, sender, script) {\n    const canForward = new this.web3.eth.Contract(\n      getAbi('aragon/Forwarder'),\n      forwarder\n    ).methods['canForward']\n\n    return canForward(sender, script).call().catch(() => false)\n  }\n\n  getDefaultGasPrice (gasLimit) {\n    return this.defaultGasPriceFn(gasLimit)\n  }\n\n  /**\n   * Calculates and applies the gas limit and gas price for a transaction\n   *\n   * @param  {Object} transaction\n   * @param  {bool} isForwarding\n   * @return {Promise<Object>} The transaction with the gas limit and gas price added.\n   *                           If the transaction fails from the estimateGas check, the promise will\n   *                           be rejected with the error.\n   */\n  async applyTransactionGas (transaction, isForwarding = false) {\n    // If a pretransaction is required for the main transaction to be performed,\n    // performing web3.eth.estimateGas could fail until the pretransaction is mined\n    // Example: erc20 approve (pretransaction) + deposit to vault (main transaction)\n    if (transaction.pretransaction) {\n      // Calculate gas settings for pretransaction\n      transaction.pretransaction = await this.applyTransactionGas(transaction.pretransaction, false)\n      // Note: for transactions with pretransactions gas limit and price cannot be calculated\n      return transaction\n    }\n\n    // NOTE: estimateGas mutates the argument object and transforms the address to lowercase\n    // so this is a hack to make sure checksums are not destroyed\n    // Also, at the same time it's a hack for checking if the call will revert,\n    // since `eth_call` returns `0x` if the call fails and if the call returns nothing.\n    // So yeah...\n    const estimatedGasLimit = await this.web3.eth.estimateGas({ ...transaction, gas: undefined })\n    const recommendedGasLimit = await getRecommendedGasLimit(this.web3, estimatedGasLimit)\n\n    // If the gas provided in the intent is lower than the estimated gas, use the estimation\n    // when forwarding as it requires more gas and otherwise the transaction would go out of gas\n    if (!transaction.gas || (isForwarding && transaction.gas < recommendedGasLimit)) {\n      transaction.gas = recommendedGasLimit\n    }\n\n    if (!transaction.gasPrice) {\n      transaction.gasPrice = await this.getDefaultGasPrice(transaction.gas)\n    }\n\n    return transaction\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.\n   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateTransactionPath (sender, destination, methodSignature, params, finalForwarder) {\n    // Get the destination app\n    const app = await this.getApp(destination)\n    if (!app) {\n      throw new Error(`Transaction path destination (${destination}) is not an installed app`)\n    }\n\n    const methods = app.functions\n    if (!methods) {\n      throw new Error(`No functions specified in artifact for ${destination}`)\n    }\n\n    // Find the relevant method information\n    // Is the given method a full signature, e.g. 'foo(arg1,arg2,...)'\n    const fullMethodSignature =\n      Boolean(methodSignature) && methodSignature.includes('(') && methodSignature.includes(')')\n    const method = methods.find(\n      (method) => fullMethodSignature\n        ? method.sig === methodSignature\n        // If the full signature isn't given, just select the first overload declared\n        : method.sig.split('(')[0] === methodSignature\n    )\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ${destination}`)\n    }\n\n    const finalForwarderProvided = isAddress(finalForwarder)\n    const directTransaction = await createDirectTransactionForApp(sender, app, method.sig, params, this.web3)\n\n    // We can already assume the user is able to directly invoke the action if:\n    //   - The method has no ACL requirements and no final forwarder was given, or\n    //   - The final forwarder matches the sender\n    if (\n      (method.roles.length === 0 && !finalForwarderProvided) ||\n      addressesEqual(finalForwarder, sender)\n    ) {\n      try {\n        // `applyTransactionGas` can throw if the transaction will fail\n        return [await this.applyTransactionGas(directTransaction)]\n      } catch (_) {\n        // If the direct transaction fails, we give up as we should have been able to\n        // perform the action directly\n        return []\n      }\n    }\n\n    // Failing this, attempt transaction pathing algorithm with forwarders\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders.map(\n        (forwarder) => forwarder.proxyAddress\n      )\n    )\n\n    let forwardersWithPermission\n    if (finalForwarderProvided) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        // Final forwarder was given, but did not match any available forwarders, so no path\n        // could be found\n        return []\n      }\n\n      // Only attempt to find path with declared final forwarder; assume the final forwarder\n      // is able to invoke the action\n      forwardersWithPermission = [finalForwarder]\n    } else {\n      // Find entities with the required permissions\n      const permissions = await this.permissions.pipe(first()).toPromise()\n      const destinationPermissions = permissions[destination]\n      const roleSig = app.roles.find(\n        (role) => role.id === method.roles[0]\n      ).bytes\n      const allowedEntities = dotprop.get(\n        destinationPermissions,\n        `${roleSig}.allowedEntities`,\n        []\n      )\n\n      // No one has access, so of course we don't as well\n      if (allowedEntities.length === 0) {\n        return []\n      }\n\n      // User may have permission; attempt direct transaction\n      if (\n        includesAddress(allowedEntities, sender) ||\n        includesAddress(allowedEntities, ANY_ENTITY)\n      ) {\n        try {\n          // `applyTransactionGas` can throw if the transaction will fail\n          return [await this.applyTransactionGas(directTransaction)]\n        } catch (_) {\n          // Don't immediately fail as the permission could have parameters applied that\n          // disallows the user from the current action and forces us to use the full\n          // pathing algorithm\n        }\n      }\n\n      // Find forwarders with permission to perform the action\n      forwardersWithPermission = forwarders.filter(\n        (forwarder) => includesAddress(allowedEntities, forwarder)\n      )\n    }\n\n    return this.calculateForwardingPath(sender, destination, directTransaction, forwardersWithPermission)\n  }\n\n  /**\n   * Calculate the forwarding path for a transaction to `destination`\n   * that invokes `directTransaction`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {Object} directTransaction\n   * @param  {string} [forwardersWithPermission]\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateForwardingPath (sender, destination, directTransaction, forwardersWithPermission) {\n    // No forwarders can perform the requested action\n    if (forwardersWithPermission.length === 0) {\n      return []\n    }\n\n    // TODO: handle pretransactions specified in the intent\n    // This is difficult to do generically, as some pretransactions\n    // (e.g. token approvals) only work if they're for a specific target\n    delete directTransaction.pretransaction\n\n    const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction, this.web3)\n\n    // Check if one of the forwarders that has permission to perform an action\n    // with `sig` on `address` can forward for us directly\n    for (const forwarder of forwardersWithPermission) {\n      const script = encodeCallScript([directTransaction])\n      if (await this.canForward(forwarder, sender, script)) {\n        const transaction = createForwarderTransaction(forwarder, script)\n        try {\n          const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action with this\n          // forwarder\n          return [await this.applyTransactionGas(transactionWithFee, true), directTransaction]\n        } catch (err) {\n          return []\n        }\n      }\n    }\n\n    // Get a list of all forwarders (excluding the forwarders with direct permission)\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders\n        .map((forwarder) => forwarder.proxyAddress)\n        .filter((forwarder) => !includesAddress(forwardersWithPermission, forwarder))\n    )\n\n    // Set up the path finding queue\n    // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n    // In other words: it is an array of tuples, where the first index of the tuple\n    // is the current path and the second index of the tuple is the\n    // queue (a list of unexplored forwarder addresses) for that path\n    const queue = forwardersWithPermission.map((forwarderWithPermission) => {\n      return [\n        [\n          createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])),\n          directTransaction\n        ], forwarders\n      ]\n    })\n\n    // Find the shortest path via a breadth-first search of forwarder paths.\n    // We do a breadth-first instead of depth-first search because:\n    //   - We assume that most forwarding paths will be quite short, so it should be faster\n    //     to check in \"stages\" rather than exhaust single paths\n    //   - We don't currently protect against cycles in the path, and so exhausting single\n    //     paths can be wasteful if they result in dead ends\n    // TODO(onbjerg): Should we find and return multiple paths?\n    do {\n      const [path, [forwarder, ...nextQueue]] = queue.shift()\n\n      // Skip if no forwarder or the path is longer than 5\n      if (!forwarder || path.length > 5) continue\n\n      // Get the previous forwarder address\n      const previousForwarder = path[0].to\n\n      // Encode the previous transaction into an EVM callscript\n      const script = encodeCallScript([path[0]])\n\n      if (await this.canForward(previousForwarder, forwarder, script)) {\n        if (await this.canForward(forwarder, sender, script)) {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // and this forwarder can forward for our address, so we have found a path\n          const transaction = createForwarderTransaction(forwarder, script)\n\n          // Only apply pretransactions and gas to the first transaction in the path\n          // as it's the only one that will be executed by the user\n          try {\n            const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n            // `applyTransactionGas` can throw if the transaction will fail\n            // If that happens, we give up as we should've been able to perform the action with this\n            // forwarding path\n            return [await this.applyTransactionGas(transactionWithFee, true), ...path]\n          } catch (err) {\n            return []\n          }\n        } else {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // but this forwarder can not forward for our address, so we add it as a\n          // possible path in the queue for later exploration.\n          queue.push([\n            [createForwarderTransaction(forwarder, script), ...path],\n            // Avoid including the current forwarder as a candidate for the next step\n            // in the path. Note that this is naive and may result in repeating cycles,\n            // but the maximum path length would prevent against infinite loops\n            forwarders.filter((nextForwarder) => nextForwarder !== forwarder)\n          ])\n        }\n      }\n\n      // We add the current path on the back of the queue again, but we shorten\n      // the list of possible forwarders.\n      queue.push([path, nextQueue])\n    } while (queue.length)\n\n    return []\n  }\n}\n\n// Re-export some web3 utilities\nexport { apm, getRecommendedGasLimit }\nexport { resolve as ensResolve } from './ens'\n\n// Re-export the AddressIdentityProvider abstract base class\nexport { AddressIdentityProvider } from './identity'\n\n// Re-export the Aragon RPC providers\nexport { providers } from '@aragon/rpc-messenger'\n"],"file":"index.js"}