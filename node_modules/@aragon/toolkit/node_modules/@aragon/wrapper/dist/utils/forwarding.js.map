{"version":3,"sources":["../../src/utils/forwarding.js"],"names":["FORWARD_SIG","isValidForwardCall","calldata","replace","selector","substring","evmscriptData","length","parseForwardCall","offset","parseInt","startIndex","dataLength"],"mappings":"iEAyduB;sHAzdhB,KAAMA,CAAAA,WAAW,CAAG,YAApB,CAAiC;AAExC;;;;;;;;;;oCAWO,QAASC,CAAAA,kBAAT,CAA6BC,QAA7B,CAAuC,CAE5CA,QAAQ,CAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,EAAxB,CAFiC,CAG5C;AAH4C,KAItCC,CAAAA,QAAQ,CAAGF,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAAsB,CAAtB,CAJ2B,CAMtCC,aAAa,CAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CANsB,CAK5C;AAEA;AACA;AACA,MAAO,YAAKD,QAAL,IAAoBJ,WAApB,EAA2D,GAAxB,EAAAM,aAAa,CAACC,MACzD,CAED;;;;;;GAOO,QAASC,CAAAA,gBAAT,CAA2BN,QAA3B,CAAqC,CAE1CA,QAAQ,CAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,EAAxB,CAF+B,CAG1C;AAH0C,KAIpCG,CAAAA,aAAa,CAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAJoB,CAOpCI,MAAM,CAAyD,CAAtD,CAAAC,QAAQ,aAAMJ,aAAa,CAACD,SAAd,CAAwB,CAAxB,CAA2B,EAA3B,CAAN,EAAwC,EAAxC,CAPmB,CASpCM,UAAU,CAAGF,MAAM,CAAG,EATc,CAYpCG,UAAU,CAAsE,CAAnE,CAAAF,QAAQ,aAAMJ,aAAa,CAACD,SAAd,CAAwBI,MAAxB,CAAgCE,UAAhC,CAAN,EAAqD,EAArD,CAZe,CAK1C;AACA;AAOA;AACA,kBAAYL,aAAa,CAACD,SAAd,CAAwBM,UAAxB,CAAoCA,UAAU,CAAGC,UAAjD,CAAZ,CACD","sourcesContent":["export const FORWARD_SIG = '0xd948d468' // function forward(bytes)\n\n/**\n * Tells if the given calldata (as a bytes string) is a valid invocation of\n * `forward(bytes)`.\n *\n * It will return true only if the given calldata starts with the forward\n * function signature and follows with at least an empty bytes array properly\n * ABI encoded following the convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {boolean}\n */\nexport function isValidForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // First 4 bytes represent the function selector\n  const selector = calldata.substring(0, 8)\n  // Drop selector and grab the argument data\n  const evmscriptData = calldata.substring(8)\n  // Since arrays of bytes are encoded following the [offset][length][data]\n  // format, we expect it to have at least two words length (empty data scenario)\n  return `0x${selector}` === FORWARD_SIG && evmscriptData.length >= 128\n}\n\n/**\n * Parse the evmscript of a forward call following the byte ABI encoding\n * convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {string} Array of bytes representing the forwarded evmscript\n */\nexport function parseForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // Drop function selector and grab the argument data (of type bytes)\n  const evmscriptData = calldata.substring(8)\n  // Parse first word of the bytes array to get data offset\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const offset = parseInt(`0x${evmscriptData.substring(0, 64)}`, 16) * 2\n  // The first word in the data is its length (uint256); actual data starts after\n  const startIndex = offset + 64\n  // Parse length of the data stored\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const dataLength = parseInt(`0x${evmscriptData.substring(offset, startIndex)}`, 16) * 2\n  // Grab the data stored in the bytes array\n  return `0x${evmscriptData.substring(startIndex, startIndex + dataLength)}`\n}\n"],"file":"forwarding.js"}