{"version":3,"sources":["../../src/utils/FileFetcher.js"],"names":["axios","require","sanitizePath","path","replace","sanitizeUrl","url","startsWith","endsWith","FileFetcher","constructor","ipfsGateway","providers","Map","set","gateway","getFullPath","provider","location","supportsProvider","Error","baseLocation","get","fetch","config","response","responseType","transformResponse","data","has"],"mappings":"kPAyduB;uyBAzdvB,KAAMA,CAAAA,KAAK,CAAGC,OAAO,CAAC,OAAD,CAArB,CAEA,QAASC,CAAAA,YAAT,CAAuBC,IAAvB,CAA6B,CAC3B;AACA,MAAOA,CAAAA,IAAI,CAACC,OAAL,CAAa,QAAb,CAAuB,EAAvB,CACR,CAED,QAASC,CAAAA,WAAT,CAAsBC,GAAtB,CAA2B,CASzB,MAPKA,CAAAA,GAAG,CAACC,UAAJ,CAAe,SAAf,CAAD,EAA+BD,GAAG,CAACC,UAAJ,CAAe,UAAf,CAOnC,GANED,GAAG,kBAAaA,GAAb,CAML,EAJKA,GAAG,CAACE,QAAJ,CAAa,GAAb,CAIL,GAHEF,GAAG,WAAMA,GAAN,KAGL,EAAOA,GACR,CAEc,KAAMG,CAAAA,WAAY,CAC/BC,WAAW,CAAE,CAAEC,WAAW,CAAG,EAAhB,EAAuB,EAAzB,CAA6B,CACtC,KAAKC,SAAL,CAAiB,GAAIC,CAAAA,GAAJ,CAAQ,CAAC,CAAC,MAAD,CAAD,CAAR,CADqB,CAGlCF,WAHkC,EAIpC,KAAKC,SAAL,CAAeE,GAAf,CAAmB,MAAnB,CAA2B,CAAEC,OAAO,CAAEV,WAAW,CAACM,WAAD,CAAtB,CAA3B,CAEH,CAEDK,WAAW,CAAEC,QAAF,CAAYC,QAAZ,CAAsBf,IAAtB,CAA4B,CACrC,GAAI,CAAC,KAAKgB,gBAAL,CAAsBF,QAAtB,CAAL,CACE,KAAM,IAAIG,CAAAA,KAAJ,mCAAqCH,QAArC,EAAN,CAGF;AACA,KAAMI,CAAAA,YAAY,CAAgB,MAAb,GAAAJ,QAAQ,WACtB,KAAKL,SAAL,CAAeU,GAAf,CAAmB,MAAnB,EAA2BP,OADL,SACeG,QADf,EAEzBA,QAFJ,CAIA,gBAAUb,WAAW,CAACgB,YAAD,CAArB,SAAsCnB,YAAY,CAACC,IAAD,CAAlD,CACD,CAED,KAAMoB,CAAAA,KAAN,CAAaN,QAAb,CAAuBC,QAAvB,CAAiCf,IAAjC,CAAuCqB,MAAvC,CAA+C,CAC7C,KAAMC,CAAAA,QAAQ,CAAG,KAAMzB,CAAAA,KAAK,CAAC,KAAKgB,WAAL,CAAiBC,QAAjB,CAA2BC,QAA3B,CAAqCf,IAArC,CAAD,kBACvBqB,MADuB,EAE1BE,YAAY,CAAE,MAFY,CAI1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,iBAAiB,CAAE,IAZO,GAA5B,CAcA,MAAOF,CAAAA,QAAQ,CAACG,IACjB,CAEDT,gBAAgB,CAAEF,QAAF,CAAY,CAC1B,MAAO,MAAKL,SAAL,CAAeiB,GAAf,CAAmBZ,QAAnB,CACR,CA1C8B,C","sourcesContent":["const axios = require('axios')\n\nfunction sanitizePath (path) {\n  // Disallow a path being declared for the root or navigating to sibling paths\n  return path.replace(/^[./]+/, '')\n}\n\nfunction sanitizeUrl (url) {\n  // Sanitize url to make sure it has a protocol and ends with a /\n  if (!url.startsWith('http://') && !url.startsWith('https://')) {\n    url = `http://${url}`\n  }\n  if (!url.endsWith('/')) {\n    url = `${url}/`\n  }\n\n  return url\n}\n\nexport default class FileFetcher {\n  constructor ({ ipfsGateway = '' } = {}) {\n    this.providers = new Map([['http']])\n\n    if (ipfsGateway) {\n      this.providers.set('ipfs', { gateway: sanitizeUrl(ipfsGateway) })\n    }\n  }\n\n  getFullPath (provider, location, path) {\n    if (!this.supportsProvider(provider)) {\n      throw new Error(`Provider not supported: ${provider}`)\n    }\n\n    // When IPFS is the provider, the declared location is a CID\n    const baseLocation = provider === 'ipfs'\n      ? `${this.providers.get('ipfs').gateway}${location}`\n      : location\n\n    return `${sanitizeUrl(baseLocation)}${sanitizePath(path)}`\n  }\n\n  async fetch (provider, location, path, config) {\n    const response = await axios(this.getFullPath(provider, location, path), {\n      ...config,\n      responseType: 'text',\n\n      // This is needed to disable the default behavior of axios, which\n      // always tries to use JSON.parse() even if `responseType` is \"text\".\n      //\n      // See:\n      //   https://github.com/axios/axios/issues/907#issuecomment-322054564\n      //\n      // Although the comment states that 'undefined' should work, setting 'undefined' on\n      // axios@0.19.0 does not override the default, so we have to use null\n      transformResponse: null\n    })\n    return response.data\n  }\n\n  supportsProvider (provider) {\n    return this.providers.has(provider)\n  }\n}\n"],"file":"FileFetcher.js"}