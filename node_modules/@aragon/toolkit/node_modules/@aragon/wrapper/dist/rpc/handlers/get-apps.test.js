"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_rxjs=require("rxjs"),_getApps=_interopRequireDefault(require("./get-apps"));function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0// force cache invalidation
).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should return a subscription for the entire app list if observing all",async t=>{t.plan(2);// arrange
const initialApps=[{appId:"coolApp",kernelAddress:"0x123",contractAddress:"0xcoolApp",abi:"abi for coolApp",isForwarder:!1,name:"Cool App",proxyAddress:"0x456",icons:[{src:"icon_link"}]}],appsMock=new _rxjs.BehaviorSubject(initialApps),identifiersMock=(0,_rxjs.of)({"0x456":"cool identifier","0x789":"voting identifier"}),result=await(0,_getApps.default)({params:["observe","all"]},{},{apm:{getContentPath:(content,path)=>"url/".concat(path)},apps:appsMock,appIdentifiers:identifiersMock}),expectedInitialApps=[{appAddress:"0x456",appId:"coolApp",appImplementationAddress:"0xcoolApp",identifier:"cool identifier",isForwarder:!1,kernelAddress:"0x123",name:"Cool App",icons:[{src:"url/icon_link"}]}],expectedEndApps=[].concat(expectedInitialApps,{appAddress:"0x789",appId:"votingApp",appImplementationAddress:"0xvotingApp",identifier:"voting identifier",isForwarder:!0,kernelAddress:"0x123",name:"Voting App",icons:[{src:"url/icon_link"}]});let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,expectedInitialApps):1===emitIndex?t.deepEqual(value,expectedEndApps):t.fail("too many emissions"),emitIndex++});// We need apps' second emission to fire after the identifiers have emitted,
// so that the combineLatest doesn't skip the initial value
const endApps=[].concat(initialApps,{appId:"votingApp",kernelAddress:"0x123",contractAddress:"0xvotingApp",abi:"abi for votingApp",isForwarder:!0,name:"Voting App",proxyAddress:"0x789",icons:[{src:"icon_link"}]});appsMock.next(endApps)}),(0,_ava.default)("should return a subscription for the entire app list via initial RPC API",async t=>{t.plan(2);// arrange
const initialApps=[{appId:"coolApp",kernelAddress:"0x123",contractAddress:"0xcoolApp",abi:"abi for coolApp",isForwarder:!1,name:"Cool App",icon:"icon link",proxyAddress:"0x456"}],endApps=[].concat(initialApps,{appId:"votingApp",kernelAddress:"0x123",contractAddress:"0xvotingApp",abi:"abi for votingApp",isForwarder:!0,name:"Voting App",icon:"icon link",proxyAddress:"0x789"}),appsMock=(0,_rxjs.of)(initialApps,endApps),result=await(0,_getApps.default)({params:[]},{},{apps:appsMock});// assert
let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,initialApps):1===emitIndex?t.deepEqual(value,endApps):t.fail("too many emissions"),emitIndex++})}),(0,_ava.default)("should return the initial value for the entire app list if getting all",async t=>{t.plan(1);// arrange
const initialApps=[{appId:"coolApp",kernelAddress:"0x123",contractAddress:"0xcoolApp",abi:"abi for coolApp",isForwarder:!1,name:"Cool App",proxyAddress:"0x456",icons:[{src:"icon_link"}]}],appsMock=new _rxjs.BehaviorSubject(initialApps),identifiersMock=(0,_rxjs.of)({"0x456":"cool identifier","0x789":"voting identifier"}),result=await(0,_getApps.default)({params:["get","all"]},{},{apm:{getContentPath:(content,path)=>"url/".concat(path)},apps:appsMock,appIdentifiers:identifiersMock}),expectedApps=[{appAddress:"0x456",appId:"coolApp",appImplementationAddress:"0xcoolApp",identifier:"cool identifier",isForwarder:!1,kernelAddress:"0x123",name:"Cool App",icons:[{src:"url/icon_link"}]}];let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,expectedApps):t.fail("too many emissions"),emitIndex++});// Even though this is filtered out, we need apps' second emission to fire after the identifiers
// have emitted, so that the combineLatest doesn't skip the initial value
const endApps=[].concat(initialApps,{appId:"votingApp",kernelAddress:"0x123",contractAddress:"0xvotingApp",abi:"abi for votingApp",isForwarder:!0,name:"Voting App",proxyAddress:"0x789",icons:[{src:"icon_link"}]});appsMock.next(endApps)}),(0,_ava.default)("should return a subscription for just the current app if observing current",async t=>{t.plan(2);// arrange
const currentAppAddress="0x456",initialApp={appId:"coolApp",contractAddress:"0xcoolApp",kernelAddress:"0x123",abi:"abi for coolApp",isForwarder:!1,name:"Cool App",proxyAddress:"0x456",icons:[{src:"icon_link"}]},appsMock=new _rxjs.BehaviorSubject([initialApp]),identifiersMock=(0,_rxjs.of)({"0x456":"cool identifier"}),result=await(0,_getApps.default)({params:["observe","current"]},{address:"0x456"},{apm:{getContentPath:(content,path)=>"url/".concat(path)},apps:appsMock,appIdentifiers:identifiersMock});// assert
let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,{appAddress:currentAppAddress,appId:"coolApp",appImplementationAddress:"0xcoolApp",identifier:"cool identifier",isForwarder:!1,kernelAddress:"0x123",name:"Cool App",icons:[{src:"url/icon_link"}]}):1===emitIndex?t.deepEqual(value,{appAddress:currentAppAddress,appId:"new coolApp",appImplementationAddress:"0xcoolApp",identifier:"cool identifier",isForwarder:!1,kernelAddress:"0x123",name:"Cool App",icons:[{src:"url/icon_link"}]}):t.fail("too many emissions"),emitIndex++});// We need apps' second emission to fire after the identifiers have emitted,
// so that the combineLatest doesn't skip the initial value
const endApp=_objectSpread({},initialApp,{appId:"new coolApp"});appsMock.next([// This extra app should be filtered out
{appId:"votingApp",kernelAddress:"0x123",contractAddress:"0xvotingApp",abi:"abi for votingApp",isForwarder:!0,name:"Voting App",proxyAddress:"0x789",icons:[{src:"icon_link"}]},endApp])}),(0,_ava.default)("should return the initial value for just the current app if getting current",async t=>{t.plan(1);// arrange
const initialApp={appId:"coolApp",contractAddress:"0xcoolApp",kernelAddress:"0x123",abi:"abi for coolApp",isForwarder:!1,name:"Cool App",proxyAddress:"0x456",icons:[{src:"icon_link"}]},endApp=_objectSpread({},initialApp,{appId:"new coolApp"}),appsMock=new _rxjs.BehaviorSubject([initialApp]),identifiersMock=(0,_rxjs.of)({"0x456":"cool identifier"}),result=await(0,_getApps.default)({params:["get","current"]},{address:"0x456"},{apm:{getContentPath:(content,path)=>"url/".concat(path)},apps:appsMock,appIdentifiers:identifiersMock});// assert
let emitIndex=0;// Even though this is filtered out, we need apps' second emission to fire after the identifiers
// have emitted, so that the combineLatest doesn't skip the initial value
result.subscribe(value=>{0===emitIndex?t.deepEqual(value,{appAddress:"0x456",appId:"coolApp",appImplementationAddress:"0xcoolApp",identifier:"cool identifier",isForwarder:!1,kernelAddress:"0x123",name:"Cool App",icons:[{src:"url/icon_link"}]}):t.fail("too many emissions"),emitIndex++}),appsMock.next([endApp])});
//# sourceMappingURL=get-apps.test.js.map