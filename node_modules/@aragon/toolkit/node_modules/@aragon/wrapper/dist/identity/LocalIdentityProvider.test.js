"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_index=require("./index");const ADDRESS_MIXED_CASE="0x332462D19fC398189844E6F23685e19c21F5B265",ADDRESS_LOWER_CASE="0x332462d19fc398189844e6f23685e19c21f5b265",SECOND_ADDRESS="0x552462d19fc398189844e6f23685e19c21f5b200",THIRD_ADDRESS="0x7d77398078079B0D57ed872319F26D29B5405eb8";// The tests run serially to prevent leaks between tests
// because instances of LocalIdentityProvider rely on the
// same underlying cache storage key.
_ava.default.beforeEach(async t=>{t.context.localIdentityProvider=new _index.LocalIdentityProvider,await t.context.localIdentityProvider.init()}),_ava.default.afterEach(async t=>{// Reset cache after each test because its storage is global
await t.context.localIdentityProvider.identityCache.clear()}),_ava.default.serial("should modify a local identity",async t=>{t.plan(1);const provider=t.context.localIdentityProvider,expectedName="vitalik";await provider.modify(ADDRESS_MIXED_CASE,{name:expectedName});const identityMetadata=await provider.resolve(ADDRESS_MIXED_CASE);t.is(identityMetadata.name,expectedName)}),_ava.default.serial("should throw an error when no name is given",async t=>{t.plan(2);const provider=t.context.localIdentityProvider,error=await t.throwsAsync(async()=>{await provider.modify(ADDRESS_MIXED_CASE)},{instanceOf:Error,message:"name is required when modifying a local identity"});t.is(error.message,"name is required when modifying a local identity")}),_ava.default.serial("should return null when resolving non existent local identity",async t=>{t.plan(1);const provider=t.context.localIdentityProvider,identityMetadata=await provider.resolve(ADDRESS_LOWER_CASE);t.is(identityMetadata,null)}),_ava.default.serial("should be case insensitive when resolving",async t=>{t.plan(1);const provider=t.context.localIdentityProvider,expectedName="vitalik";await provider.modify(ADDRESS_MIXED_CASE,{name:expectedName});const identityMetadata=await provider.resolve(ADDRESS_LOWER_CASE);t.is(identityMetadata.name,expectedName)}),_ava.default.serial("should be case insensitive when modifying",async t=>{t.plan(2);const provider=t.context.localIdentityProvider,overwrittenName="gavin";await provider.modify(ADDRESS_MIXED_CASE,{name:"vitalik"}),await provider.modify(ADDRESS_LOWER_CASE,{name:overwrittenName});const firstIdentityMetadata=await provider.resolve(ADDRESS_MIXED_CASE),secondidentityMetadata=await provider.resolve(ADDRESS_LOWER_CASE);t.is(firstIdentityMetadata.name,overwrittenName),t.is(secondidentityMetadata.name,overwrittenName)}),_ava.default.serial("should always have createAt in metadata",async t=>{t.plan(1);const provider=t.context.localIdentityProvider;await provider.modify(ADDRESS_MIXED_CASE,{name:"vitalik"});const identityMetadata=await provider.resolve(ADDRESS_LOWER_CASE);t.truthy(identityMetadata.createdAt)}),_ava.default.serial("removes selected local identities",async t=>{t.plan(4);const provider=t.context.localIdentityProvider,name="vitalik";await provider.modify(ADDRESS_MIXED_CASE,{name}),await provider.modify(SECOND_ADDRESS,{name});const{name:name1}=await provider.resolve(ADDRESS_MIXED_CASE);t.is(name1,name);const{name:name2}=await provider.resolve(SECOND_ADDRESS);t.is(name2,name),await provider.remove(ADDRESS_MIXED_CASE),t.falsy((await provider.resolve(ADDRESS_MIXED_CASE)));const{name:name4}=await provider.resolve(SECOND_ADDRESS);t.is(name4,name)}),_ava.default.serial("getAll will return all local identities with lowercase address keys",async t=>{t.plan(7);const provider=t.context.localIdentityProvider,name="vitalik";await provider.modify(ADDRESS_MIXED_CASE,{name}),await provider.modify(SECOND_ADDRESS,{name}),await provider.modify(THIRD_ADDRESS,{name});const all=await provider.getAll();t.is(Object.keys(all).length,3),t.is(all[ADDRESS_LOWER_CASE].name,name),t.is(all[SECOND_ADDRESS].name,name),t.is(all[THIRD_ADDRESS.toLowerCase()].name,name),t.truthy(all[ADDRESS_LOWER_CASE].createdAt),t.truthy(all[SECOND_ADDRESS].createdAt),t.truthy(all[THIRD_ADDRESS.toLowerCase()].createdAt)}),_ava.default.serial("search should return an array of results of freely matching identities",async t=>{// t.plan(7)
const provider=t.context.localIdentityProvider,identities=[["0x1110000000000000000000000000000000000001","James Baldwin"],["0x1120000000000000000000000000000000000001","David Deutsch"],["0x3000000000000000000000000000000000000001","Isaac Newton"],["0x4000000000000000000000000000000000000001","Henry Newton"],["0x6000000000000000000000000000000000000001","Marie Curie"],["0x7000000000000000000000000000000000000001","Winnie the Pooh"],["0x8900000000088888870000000000000000000001","Richard Feynman"],["0x0900000000000000000000000000000000000001","Aristotle"],["0xa000000000000000000000000000000000000002","0x3b The Who"],["0x3b00000000000000000000000000000000000002","The man who sold the world? (Nirvana not $Bowie)"]],searchTermToExpectation={D:{names:["James Baldwin","David Deutsch","Richard Feynman","The man who sold the world? (Nirvana not $Bowie)"]},xn:{names:[]},"0a":{names:[]},eu:{names:["David Deutsch"]},new:{names:["Isaac Newton","Henry Newton"]},win:{names:["James Baldwin","Winnie the Pooh"]},jam:{names:["James Baldwin"]},ari:{names:["Marie Curie","Aristotle"]},"0x09":{names:["Aristotle"]},"0x11":{names:["James Baldwin","David Deutsch"]},"0x3b":{names:["0x3b The Who","The man who sold the world? (Nirvana not $Bowie)"]},who:{names:["0x3b The Who","The man who sold the world? (Nirvana not $Bowie)"]}};// save test identities
for(const[address,name]of identities)await provider.modify(address,{name});for(const[searchTerm,expectedResult]of Object.entries(searchTermToExpectation)){const results=await provider.search(searchTerm),resultNames=results.map(({name})=>name);t.is(results.length,expectedResult.names.length,"Matching the result count when searching for ".concat(searchTerm)),t.deepEqual(resultNames,expectedResult.names)}});
//# sourceMappingURL=LocalIdentityProvider.test.js.map